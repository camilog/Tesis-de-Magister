\chapter{Antecedentes}
\section{\emph{Pedersen Commitments}}

Muchas primitivas criptográficas tienen como propósito ``ocultar'' información, es decir, transformar un cierto mensaje en una 
secuencia que, a primera vista, parecer ser totalmente aleatoria, y que solo puede ser ``comprendida'' (o transformada en el 
mensaje original) con el uso de una cierta clave secreta.

Existe una variante de la descripción anterior, que se presenta cuando la clave para descifrar un cierto texto secreto, es el 
mismo mensaje original. A un protocolo así se le llama \emph{protocolo de commitment} (compromiso), ya que no posee como finalidad 
comunicar un mensaje a otra persona de manera secreta, sino que más bien comprometer a un cierto participante a un cierto mensaje, 
dándole la oportunidad que este mensaje pueda permanecer en secreto, pero que \emph{a posteriori} la única manera de aceptar su 
mensaje es que revele el valor con el cual se comprometió en un principio.

\todo{Agregar descripción matemática de un protocolo de \emph{commitment}}

Existen varias herramientas matemáticas que nos permiten instanciar un protocolo de \emph{commitment}. En particular en este 
trabajo se utilizó el protocolo \emph{Pedersen Commitment}\cite{pedersen1991non}, el cual se basa en la dificultad de resolver el 
problema del logaritmo discreto\footnote{\url{http://www.doc.ic.ac.uk/~mrh/330tutor/ch06s02.html}}.

\emph{Pedersen Commitment Scheme:} Sea $G_q$ un grupo de orden $q$, en donde el problema del logaritmo discreto se crea dificil 
de resolver. Sean $g,h$ generadores de $G_q$ elegidos de manera aleatoria. Sea $s \in \mathbb{Z}_q$ un secreto al cual el 
participante se comprometerá. Además sea $r \in \mathbb{Z}_q$ elegido aleatoriamente. Se le llama un \emph{Pedersen commitment} 
sobre $s$ al valor: $$c := g^s h^r$$

Los \emph{Pedersen commitments} brindan dos propiedades importantes: 
  ocultamiento perfecto (\emph{unconditionally hiding}) y 
  vinculación computacional (\emph{computationally binding}). 
Esto quiere decir que, si un participante calcula un \emph{commitment} sobre un 
  cierto valor $s$, 
  (1) la persona se compromete a dicho valor (pero sin revelarlo), ya que, 
  por un lado es imposible para un tercero conocer $s$ a partir de $c$, 
  y (2) es computacionalmente difícil demostrar que dentro de $c$ existe un valor distinto a $s$.

\section{\emph{Zero-Knowledge Proofs}}

Una \emph{zero-knowledge proof} permite a una persona poder demostrar el conocimiento de cierto valor $\alpha$ que cumple una propiedad 
  (en Inglés, \emph{statement}), sin revelar el valor de $\alpha$ (el testigo) en esa demostración.
Se pueden construir demostraciones para diferentes tipos de propiedades (\emph{statements}), como por ejemplo: el conocimiento de 
un logaritmo discreto; la igualdad de diferentes logaritmos con distintas bases, además de combinaciones con operadores 
lógicos, entre otros. Además existen maneras para poder demostrar propiedades genéricas sobre logaritmos discretos \cite{camenisch1997proof}.
  
Existe una estrecha relación entre \emph{commitment} y \emph{zero-knowledge proofs}, ya que estás últimas generalmente demuestran 
propiedades que poseen valores ``escondidos'' dentro de un \emph{commitment}, por lo que se puede convencer a un tercero que un cierto 
valor que no deseo revelar, sigue una cierta propiedad esperada.

La demostración que se utiliza a lo largo del protocolo descrito en este trabajo, es la llamada \emph{proof-of-knowledge}, la cual 
consiste en que el \emph{prover}\footnote{En el protocolo de \emph{Zero-Knowledge proof} existen dos partes: (1) el 
\emph{prover}, quien tiene 
como misión demostrarle al (2) \emph{verifier} la propiedad deseada.}  debe demostrar el conocimiento de un valor $\alpha$, 
que hace que la proposición $P(\alpha)$ sea verdadera\footnote{Se denota esto como $PoK\{\alpha : P(\alpha)\}$. 
Los valores en $P(\alpha)$ se asumen públicos, a excepción de $\alpha$.}. 
Ejemplos de estas demostraciones son las siguientes:
\begin{enumerate}
  \item Logaritmo discreto: $PoK\{w : y = g^w\}$
  \item Uno de dos logaritmos discretos: $PoK\{x_1, x_2 : h_1 = g^{x_1} \lor h_2 = g^{x_2}\}$
  \item Dos logaritmos discretos: $PoK\{x_1, x_2 : h_1 = g^{x_1} \land h_2 = g^{x_2}\}$
  \item Valores en \emph{Pedersen Commitment}: $PoK\{x, r : c = g^x h^r\}$
\end{enumerate}

\section{Implementaciones de \emph{DC-Nets} relacionadas}

El estudio de las \emph{DC-Nets} como herramienta para brindar anonimato se ha incrementado en los últimos años, debido a los ataques 
encontrador a protocolos que ofrecían más rapidez a la hora de entregar mensajes, como lo es \emph{onion-routing}. En 
\cite{wright2002analysis} se deja claro que el protocolo \emph{DC-Net} es el que posee mayor seguridad a la hora de asegurar anonimato, 
(frente a otras alternativas como \emph{mixnets} y \emph{onion-routing})
pero sufre problemas de escalabilidad. Es por ello que los esfuerzos de muchas investigaciones ha sido como mantener la 
seguridad que ofrece el protocolo original, pero apuntando a arreglar los problemas de escabalidad que posee, y así construir 
una alternativa viable y eficiente a \emph{TOR} a la hora de mantenerse anónimo mientras se navega por Internet.

La primera implementación de una variante del protocolo \emph{DC-Net} se encuentra en \cite{goel2003herbivore}, donde se presenta el 
sistema \emph{Herbivore}, el cual logra soslayar el problema de escalabilidad creando pequeños \emph{cluster} de participantes, 
reduciendo la cantidad de conexiones necesarias para enviar los mensajes anónimos. El sistema logra escalar hasta unas decenas 
de participantes. Sin embargo, no posee ninguna manera de asegurar la integridad del sistema, por lo que es vulnerable a 
ataques realizados por participantes maliciosos, con el objetivo de estropear el desarrollo del protocolo.

Luego de \emph{Herbivore} las implementaciones que siguieron fueron realizadas por el grupo 
\emph{dedis (Decentralized and Distributed Systems Research)}\footnote{\url{http://dedis.cs.yale.edu/}} de \emph{Yale University}, 
quienes presentan tres sistemas: \emph{Dissent}, \emph{D3} y \emph{Verdict} 
\cite{corrigan2010dissent, wolinsky2012dissent, wolinsky2012scalable, corrigan2012proactively}. Estos sistemas tienen como principal 
objetivo atacar el problema de escalabilidad presente en las \emph{DC-Net} y que \emph{Herbivore} lograba aumentar pero no muy 
significativamente. La solución apunta a utilizar servidores adicionales que participan 
en la comunicación entre los participantes, logrando de esta manera que los participantes no se 
deban conectar entre todos ellos (como una \emph{DC-Net} tradicional), 
sino que se conectan a servidores intermediarios quienes funcionan como \emph{brokers} y entregan los mensajes a todos los participantes 
presentes. Los sistemas propuestos fueron evolucionando, llegando a realizarse pruebas con hasta 1000 participantes enviando mensajes. 
Si bien en \emph{Verdict} logran incluir criptografía para evitar que participantes maliciosos 
ataquen el sistema, el sistema se basa en que cada participante debe depositar una cuota de 
confianza en uno de estos servidores intermediarios que utiliza. Si bien esto puede parecer poco 
(depositar confianza en un servidor externo), en la práctica lleva a muchas dudas y dificultad 
para llevar a cabo, e incorpora un elemento que no está presente en el protocolo original. 
En la época actual, la confianza es un elemento que debe ser manejado con cuidado, procurando, 
desde el punto de vista científico, disminuir y en mejor medida evitar, que los participantes 
deban confiar en terceros para poder asegurar su privacidad. 

Luego de \emph{Verdict}, las implementaciones que siguieron tenían como objetivo 
aumentar aun más la escalabilidad del sistema, llegando a un orden de magnitud más 
con la adición de técnicas derivadas de \emph{Private Information Retrieval (PIR)}
\todoline{agregar referencia a PIR}. 

\todo{Vuvuzela/Riposte como mejoras utilizando PIR}

\todo{Riffle}