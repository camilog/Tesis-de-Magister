\chapter{Antecedentes}
\section{\emph{Pedersen Commitments}}

Muchas primitivas criptográficas tienen como propósito ``ocultar'' información, es decir, transformar un cierto mensaje en una secuencia que, a primera vista, parecer ser totalmente aleatoria, y que solo puede ser ``comprendida'' (o transformada en el mensaje original) con el uso de una cierta clave secreta.

Existe una variante de la descripción anterior, que se presenta cuando la clave para descifrar un cierto texto secreto, es el mismo mensaje original. A un protocolo así se le llama \emph{protocolo de commitment} (compromiso), ya que no posee como finalidad comunicar un mensaje a otra persona de manera secreta, sino que más bien comprometer a un cierto participante a un cierto mensaje, dándole la oportunidad que este mensaje pueda permanecer en secreto, pero que \emph{a posteriori} la única manera de aceptar su mensaje es que revele el valor con el cual se comprometió en un principio.

\todo{Agregar descripción matemática de un protocolo de \emph{commitment}}

Existen varias herramientas matemáticas que nos permiten instanciar un protocolo de \emph{commitment}. En particular en este trabajo se utilizó el protocolo \emph{Pedersen Commitment}\cite{pedersen1991non}, el cual se basa en la dificultad de resolver el problema del logaritmo discreto \todoline{referencia para logaritmo discreto}.

\emph{Pedersen Commitment Scheme:} Sea $G_q$ un grupo de orden $q$, en donde el problema del logaritmo discreto se crea dificil de resolver. Sean $g,h$ generadores de $G_q$ elegidos de manera aleatoria. Sea $s \in \mathbb{Z}_q$ un secreto al cual el participante se comprometerá. Además sea $r \in \mathbb{Z}_q$ elegido aleatoriamente. Se le llama un \emph{Pedersen commitment} sobre $s$ al valor: $$c := g^s h^r$$

Los \emph{Pedersen commitments} brindan dos propiedades importantes: 
  ocultamiento perfecto (\emph{unconditionally hiding}) y 
  vinculación computacional (\emph{computationally binding}). 
Esto quiere decir que, si un participante calcula un \emph{commitment} sobre un 
  cierto valor $s$, 
  (1) la persona se compromete a dicho valor (pero sin revelarlo), ya que, 
  por un lado es imposible para un tercero conocer $s$ a partir de $c$, 
  y (2) es computacionalmente difícil demostrar que dentro de $c$ existe un valor distinto a $s$.

\section{\emph{Zero-Knowledge Proofs}}

Una \emph{zero-knowledge proof} permite a una persona poder demostrar el conocimiento de cierto valor $\alpha$ que cumple una propiedad 
  (en Inglés, \emph{statement}), sin revelar el valor 
  de $\alpha$ (el testigo) en esa demostración.
Se pueden construir demostraciones para diferentes tipos de propiedades 
  (\emph{statements}), como por ejemplo: el conocimiento de un logaritmo 
  discreto; la igualdad de diferentes logaritmos con distintas bases, además de combinaciones con operadores lógicos, entre otros. 
Además existen maneras para poder demostrar propiedades genéricas sobre
  logaritmos discretos 
  \cite{camenisch1997proof}.
  
  
Existe una estrecha relación entre \emph{commitment} y \emph{zero-knowledge proofs}, ya que estás últimas generalmente demuestran propiedades que poseen valores ``escondidos'' dentro de un \emph{commitment}, por lo que se puede convencer a un tercero que un cierto valor que no deseo revelar, sigue una cierta propiedad esperada.

\section{Implementaciones de \emph{DC-Nets} relacionadas}

