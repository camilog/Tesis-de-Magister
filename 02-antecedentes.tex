\chapter{Antecedentes}
\section{\emph{Pedersen Commitments}}

Muchas primitivas criptográficas tienen como propósito ``ocultar'' información, es decir, transformar un cierto mensaje en una secuencia que, a primera vista, parecer ser totalmente aleatoria, y que solo puede ser ``comprendida'' (o transformada en el mensaje original) con el uso de una cierta clave secreta.

Existe una variante de la descripción anterior, que se presenta cuando la clave para descifrar un cierto texto secreto, es el mismo mensaje original. A un protocolo así se le llama \emph{protocolo de commitment} (compromiso), ya que no posee como finalidad comunicar un mensaje a otra persona de manera secreta, sino que más bien comprometer a un cierto participante a un cierto mensaje, dándole la oportunidad que este mensaje pueda permanecer en secreto, pero que \emph{a posteriori} la única manera de aceptar su mensaje es que revele el valor con el cual se comprometió en un principio.

\todo{Agregar descripción matemática de un protocolo de \emph{commitment}}

Existen varias herramientas matemáticas que nos permiten instanciar un protocolo de \emph{commitment}. En particular en este trabajo se utilizó el protocolo \emph{Pedersen Commitment}\cite{pedersen1991non}, el cual se basa en la dificultad de resolver el problema del logaritmo discreto \todoline{referencia para logaritmo discreto}.

\emph{Pedersen Commitment Scheme:} Sea $G_q$ un grupo de orden $q$, en donde el problema del logaritmo discreto se crea dificil de resolver. Sean $g,h$ generadores de $G_q$ elegidos de manera aleatoria. Sea $s \in \mathbb{Z}_q$ un secreto al cual el participante se comprometerá. Además sea $r \in \mathbb{Z}_q$ elegido aleatoriamente. Se le llama un \emph{Pedersen commitment} sobre $s$ al valor: $$c := g^s h^r$$

Los \emph{Pedersen commitments} brindan dos propiedades importantes: 
  ocultamiento perfecto (\emph{unconditionally hiding}) y 
  vinculación computacional (\emph{computationally binding}). 
Esto quiere decir que, si un participante calcula un \emph{commitment} sobre un 
  cierto valor $s$, 
  (1) la persona se compromete a dicho valor (pero sin revelarlo), ya que, 
  por un lado es imposible para un tercero conocer $s$ a partir de $c$, 
  y (2) es computacionalmente difícil demostrar que dentro de $c$ existe un valor distinto a $s$.

\section{\emph{Zero-Knowledge Proofs}}

Una \emph{zero-knowledge proof} permite a una persona poder demostrar el conocimiento de cierto valor $\alpha$ que cumple una propiedad 
  (en Inglés, \emph{statement}), sin revelar el valor 
  de $\alpha$ (el testigo) en esa demostración.
Se pueden construir demostraciones para diferentes tipos de propiedades 
  (\emph{statements}), como por ejemplo: el conocimiento de un logaritmo 
  discreto; la igualdad de diferentes logaritmos con distintas bases, además de combinaciones con operadores lógicos, entre otros. 
Además existen maneras para poder demostrar propiedades genéricas sobre
  logaritmos discretos 
  \cite{camenisch1997proof}.
  
  
Existe una estrecha relación entre \emph{commitment} y \emph{zero-knowledge proofs}, ya que estás últimas generalmente demuestran propiedades que poseen valores ``escondidos'' dentro de un \emph{commitment}, por lo que se puede convencer a un tercero que un cierto valor que no deseo revelar, sigue una cierta propiedad esperada.

\section{Implementaciones de \emph{DC-Nets} relacionadas}

El estudio de las DC-Nets como herramienta para brindar anonimato se ha incrementado en los últimos años, debido a los ataques encontrador a protocolos que ofrecían más rapidez a la hora de entregar mensajes, como lo es \emph{onion-routing}. En \cite{wright2002analysis} queda claro que el protocolo DC-Net es el que posee mayor seguridad a la hora de asegurar anonimato, pero sufre problemas de escalabilidad. Es por ello que los esfuerzos de muchas investigaciones ha sido como mantener la seguridad que ofrece el protocolo original, pero apuntando a arreglar los problemas de escabalidad que posee, y así construir una alternativa viable y eficiente a \emph{TOR} a la hora de mantenerse anónimo mientras se navega por Internet.

La primera implementación de una variante del protocolo DC-Net se encuentra en \cite{goel2003herbivore}, quienes presentan el sistema \emph{Herbivore}, el cual logra soslayar el problema de escalabilidad creando pequeños \emph{cluster} de participantes, reduciendo la cantidad de conexiones necesarias para enviar los mensajes anónimos. \todoline{encontrarle algo malo a herbivore y hablar sobre los tiempos y ancho de banda que alcanza}.

Luego de \emph{Herbivore} se deben mencionar los trabajos realizados por el grupo \emph{dedis (Decentralized and Distributed Systems Research)}\footnote{\url{http://dedis.cs.yale.edu/}} de \emph{Yale University}, quienes presentan tres sistemas: \emph{Dissent}, \emph{D3} y \emph{Verdict} \cite{corrigan2010dissent, wolinsky2012dissent, wolinsky2012scalable, corrigan2012proactively}. Estos sistemas tienen como principal objetivo atacar el problema de escalabilidad presente en las DC-Net. Esto lo logran utilizando servidores adicionales que participan en la comunicación entre los participantes, de esta manera los participantes no se deben conectar entre ellos (como una DC-Net tradicional), sino que se conectan a servidores intermediarios quienes funcionan como \emph{brokers} y entregan los mensajes a todos los participantes presentes. Los sistemas propuestos fueron evolucionando, llegando a realizarse pruebas con hasta 1000 participantes enviando mensajes. \todoline{encontrarle algo malo a dissent y amigos y hablar sobre los tiempos y ancho de banda que alcanza}.

\todo{Vuvuzela}

\todo{Riposte}

\todo{Riffle}