\chapter{Detalles de Implementación}

La parte esencial de este trabajo esta dado por llevar a cabo una 
implementación que refleje el diseño propuesto en el capitulo anterior, 
brindando así una herramienta real a la comunidad que permita la comunicación 
anónima entre distintas partes interesadas.

Como fue explicado anteriormente, no existen muchas implementaciones de 
protocolos basados en DC-Net, por lo que llevar a cabo este trabajo conllevó 
soslayar muchos obstáculos que se detallan a continuación.

\section{Tecnologías Involucradas}

\begin{enumerate}
    \item \underline{Lenguaje de Programación:} para llevar a cabo este 
    proyecto se escogió realizarlo en \emph{Java}, debido principalmente a que 
    un objetivo era poder realizar una aplicación móvil como prueba de 
    concepto de lo implementado, y el sistema operativo móvil más común hoy en 
    día es \emph{Android}\todoline{agregar pie de pagina que apoye esto}, el 
    cual está basado en \emph{Java}. No existe una razón de fondo (mayor \emph{
    performance} o expresividad del lenguaje), por el que se escogió \emph{Java
    }, por lo que los mismos resultados se pueden lograr si se utiliza otro 
    lenguaje más común en otras implementaciones de DC-Net, como sería \emph{
    C++}.

    \item \underline{Capa de comunicación:} para la conexión entre las 
    distintas partes se utilizó \emph{ZeroMQ}, el cual es un \emph{framework} 
    de concurrencia, que permite desligarse de lidiar con problemas típicos de 
    mensajería distribuida (desconexiones, pérdida de datos, etc.) y 
    concentrarse únicamente en la lógica de la aplicación. En palabras de sus 
    autores, ``\emph{ZeroMQ} son sockets con esteroides''. Con \emph{ZeroMQ} 
    se simplifica la implementación de \emph{broadcasting} o conexiones punto 
    a punto entre los distintos participantes (ambos tipos de conexiones 
    necesarias para el protocolo).
\end{enumerate}

\section{Arquitectura del Sistema: Nodos Directorio y Participantes}

Un desafío importante a considerar en la implementación (y que el diseño del 
protocolo no se preocupa) es como descubrir la locación del resto de los 
participantes que formarán parte del \emph{anonymity-set}. Para ello se tomó 
la decisión de contar, además de los nodos participantes, con un nodo 
Directorio. Este nodo funcionará como punto de entrada al \emph{anonymity-set} 
y será el responsable de informar la dirección IP de cada uno de los nodos 
participantes. Además de esto, el nodo Directorio tiene como responsabilidad 
establecer los parámetros necesarios para correr el protocolo (número de 
participantes, valores públicos para realizar los \emph{commitments}, entre 
otros), por lo que también se vuelve un punto de control dentro del protocolo. 
Un aspecto importante es que todo lo que relaciona el protocolo con mantener 
anonimato (envío y verificaciones de demostraciones de seguridad) no pasa por 
el nodo Directorio, por lo que su incorporación no altera en nada el requisito 
de seguridad buscado (emisores de mensajes anónimos).

Esta tarea también se puede realizar entre los propios nodos participantes, 
sin la necesidad de incorporar un nodo Directorio. Si bien en esta 
investigación se priorizó la facilidad de implementar la variante utilizando 
el nodo adicional, correr alguna variante de \emph{gossip protocol} para 
informar la identidad de participantes nuevos que vayan entrando a la sala 
podría solucionar el problema. Esta segunda variante además tiene la ventaja 
de no poseer un punto vulnerable (que sería el nodo Directorio), evitando 
ataques directos al nodo Directorio, retrasando (o incluso imposibilitando) la 
creación del \emph{anonimity-set}. Reiterar que se implementó el nodo 
Directorio por simplicidad, pero se tienen en cuenta los posibles ataques que 
puede recibir el sistema, que no tienen incidencia en romper el anonimato que 
brinda el protocolo.

Actualmente el nodo Directorio inicializa estableciendo los parámetros 
públicos del protocolo y publica su dirección IP. Luego, cada nodo 
Participante que se quiera unir se conecta a la dirección pública del 
Directorio y espera que se complete la cuota de participantes establecida en 
un comienzo. Cuando se conectan $n$ participantes al Directorio, éste informa 
la dirección IP de cada uno de los participantes a todo el resto, para que 
posteriormente inicien el protocolo solo enviándose mensajes entre ellos, 
finalizando así la labor del Directorio.

\section{Primitivas Criptográficas}

En la implementación actual, la gran mayoría de las primitivas criptográficas 
han sido implementadas desde cero, valiéndose principalmente de la biblioteca 
para manejar números grandes de \emph{Java}, \emph{BigInteger}\footnote{\url{
https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html}}. Si bien 
esto no es una práctica recomendada (lo ideal es utilizar bibliotecas 
criptográficas ya probadas por la comunidad), no se ha descubierto ninguna que 
se adecúe a las necesidades requeridas por el protocolo (\emph{Pedersen 
Commitments} y \emph{ZKP} asociadas). Este punto es algo importante a resolver 
ya que, como fue dicho, la implementación de primitivas criptográficas no es 
recomendado y es imperante utilizar implementaciones ya probadas y verificadas 
por la comunidad, como lo podría ser Charm-Crypto\footnote{\url{http://charm-
crypto.com/index.html}} o Scapi\footnote{\url{https://scapi.readthedocs.
io/en/latest/}}. De todas maneras, la criptografía implementada se desarrolló 
utilizando interfaces, por lo que cuando se descubra una librería que cumpla 
los requerimientos criptográficos que se buscan, su implantación sea realizada 
de manera fácil.

\section{\emph{API} implementada}

Como fue dicho anteriormente, una contribución importante de este trabajo 
sería el hecho de estar apuntado a implementar una \emph{API} disponible para 
toda la comunidad que quiera desarrollar una aplicación que esté basada en el 
protocolo anteriormente descrito. 

La implementación anterior fue empaquetada como librería \emph{Java}, 
utilizable por otras aplicaciones al importar el archivo \emph{.jar} generado. 
Esta librería quedó con los siguientes métodos de manera pública, formando así 
la \emph{API} disponible:

\begin{itemize}
    \item \texttt{DCNETProtocol class:} clase base que entrega la \emph{API} 
    que es necesario instanciar para utilizar los métodos descritos a 
    continuación. 
    \item \texttt{boolean connectToDirectory():} luego de setear la dirección 
    IP del nodo directorio, este método
    \item \texttt{void setMessageToSend(String s, boolean b):}
    \item \texttt{void runProtocol(PrintStream p):}
    \item \texttt{ObservableParticipantsLeft:}
    \item \texttt{ObservableMessagesArrived:}
\end{itemize}

\section{Aplicación Móvil}

Para poder probar el uso de la \emph{API} implementada, se desarrolló una 
aplicación móvil prototipo, que tiene como objetivo simplificar 

\section{Observación sobre tamaños de los mensajes}

Una observación importante a realizar de la implementación realizada, es la 
cantidad de información (medida simplemente como el largo de los mensajes) que 
se envía en el protocolo. Se debe tomar como base el largo del mensaje 
original $m_i$ que cada participante debe comunicar. A esto se le debe agregar 
todas las \emph{zero-knowledge proofs} que necesita enviar, además de los \emph
{commitments}, los valores necesarios que debe comunicar para establecer 
llaves compartidas con todo el resto de la sala y considerar que en realidad 
lo que se envía en el protocolo es el mensaje $M_i$ (a la suma de todos esos 
valores enviados le denotaremos $S_i$). Por último hay que considerar también 
que entre más participantes colisionen sus mensajes, más veces será necesario 
reenviar esta cantidad de información, debido a que se debe desarrollar un 
mayor número de rondas reales.

Para medir este sobrecosto que agrega el protocolo, se realizaron varios 
experimentos, donde se varió el tamaño del mensaje original que desea 
comunicar cada participante y se observó cuanta información se enviaba 
finalmente (por ronda) al resto de la sala. Importante notar que, si bien el 
tamaño de la sala también hace variar la cantidad de información enviada, lo 
hace en un factor muy menor (con 256 participantes, se agrega 1 byte), por lo 
que esa variable se dejó de lado. Los resultados se muestran en la Tabla \ref{table:message_sizes_table}.

\begin{table}[h!]
\centering
\begin{tabular}[h!]{|c|c|c|}
\hline
$m_i$ (bytes) & $S_i$ (bytes) & $S_i / m_i$ \\ \hline
5                                   & 1633                               & 326.6       \\ \hline
10                                  & 1933                               & 193.3       \\ \hline
20                                  & 2624                               & 131.2       \\ \hline
40                                  & 3987                               & 99.7        \\ \hline
60                                  & 5288                               & 88.1        \\ \hline
80                                  & 6276                               & 78.5        \\ \hline
100                                 & 7459                               & 74.6        \\ \hline
120                                 & 8848                               & 73.7        \\ \hline
140                                 & 10281                              & 73.4        \\ \hline
200                                 & 14008                              & 70.1        \\ \hline
300                                 & 20200                              & 67.3        \\ \hline
\end{tabular}
\caption{Tamaño de mensajes enviados (por ronda)}
\label{table:message_sizes_table}
\end{table}

Cabe destacar, que entre más grande es el mensaje original a enviar, menor es 
el \emph{overhead} relativo que añade la ejecución del protocolo para asegurar 
anonimato y seguridad del sistema. Importante mencionar además que el tamaño 
del mensaje es determinado por el nodo directorio, en el comienzo del protocolo
. El directorio determina un largo máximo permitido para un mensaje. 
Independiente si algún participa envía un mensaje de largo menor a dicho 
máximo, el \emph{overhead} que presentará es el mismo que alguien que envía un 
mensaje con el largo máximo establecido por el nodo directorio.
